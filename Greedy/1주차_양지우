## Chapter 03. 그리디

def solution(n):
  count=0
  coin_types=[500,100,50,10]

  for coin in coin_types:
    count+=n//coin
    n=n%coin

  print(count)

solution(1260)

### 3-1

n,m,k=map(int,input().split())
data=list(map(int,input().split()))
data.sort(reverse=True)
sum = data[0]*k*(m//(k+1))+data[1]*1*(m//(k+1))+data[0]*(m%(k+1))
print(sum)

n,m,k=map(int,input().split())
data=list(map(int,input().split()))
data.sort(reverse=True)

count=int(m/(k+1))*k
count+=m%(k+1)

result=0
result+=(count)*data[0]
result+=(m-count)*data[1]
print(result)


### 3-2

small=0
n,m=map(int,input().split())
for i in range(n):
  data=list(map(int,input().split()))
  small=max(small,min(data))
print(small)

### 3-3

n,k=map(int,input().split())
count=0
while n!=1:
  if n%k==0:
    n=n//k
  else:
    n=n-1
  count+=1

print(count)




## Chapter 04.구현

### 4-1

n=map(int,input())
data=list(input().split())
x=1
y=1
dic={'R':1,'L':-1,'U':-1,'D':1}
for i in data:
  if i in ['R','L']:
    x+=dic[i]
  elif i in ['U','D']:
    y+=dic[i]
  if (x<1)|(x>5):
    x-=dic[i]
  if (y<1)|(y>5):
    y-=dic[i]

print([y,x])

### 4-2

h=int(input())
count=0

for i in range(h+1):
  for j in range(60):
    for z in range(60):
      if '3' in str(i)+str(j)+str(z):
        count+=1
print(count)

### 4-3

eng={'a':1,'b':2,'c':3,'d':4,'e':5,'f':6,'h':7,'i':8}
root=[[1,2],[1,-2],[2,1],[2,-1],[-1,2],[-1,-2],[-2,1],[-2,-1]]
count=0

data=input()
for i in root:
  x=eng[data[0]]+i[0]
  y=int(data[1])+i[1]
  if (x>=1)&(x<=8)&(y>=1)&(y<=8):
    count+=1
print(count)


### 4-4
n,m=map(int,input().split())
d=[[0]*m for _ in range(n)]
x,y,direction=map(int,input().split())
d[x][y]=1

array=[]
for i in range(n):
  array.append(list(map(int,input().split())))

dx=[-1,0,1,0]
dy=[0,1,0,-1]

def turn_left():
  global direction
  direction -= 1
  if direction==-1:
    direction=3
count=1
turn_time=0
while True:
  turn_left()
  nx=x+dx[direction]
  ny=y+dy[direction]
  if d[nx][ny]==0 and array[nx][ny]==0:
    d[nx][ny]=1
    x=nx
    y=ny
    count+=1
    turn_time=0
    continue
  else:
    turn_time+=1
  if turn_time==4:
    nx=x-dx[direction]
    ny=y-dy[direction]
    if array[nx][ny] ==0:
      x=nx
      y=ny
    else:
      break
    turn_time=0

print(count)



## Chapter 05. DFS/BFS

### 5-1

stack=[]
stack.append(5)
stack.append(2)
stack.append(3)
stack.append(7)
stack.pop()
stack.append(1)
stack.append(4)
stack.pop()

print(stack)
print(stack[::-1])

### 5-2

from collections import deque

queue=deque()

queue.append(5)
queue.append(2)
queue.append(3)
queue.append(7)
queue.popleft()
queue.append(1)
queue.append(4)
queue.popleft()

print(queue)
queue.reverse()
print(queue)

### 5-3

def recursive_function():
  print("재귀 함수를 호출합니다.")
  recursive_function()

recursive_function()

### 5-4

def recursive_function(i):
  if i==100:
    return
  print(i, '번째 재귀 함수에서',i+1,'번째 재귀 함수를 호출합니다.')
  recursive_function(i+1)
  print(i,'번째 재귀 함수를 종료합니다.')
recursive_function(1)

### 5-5

def factorial_iterative(n):
  result=1
  for i in range(1,n+1):
    result*=i
  return result

def factorial recursive(n):
  if n<=1:
    return 1
  return n*factorial_recursive(n-1)
